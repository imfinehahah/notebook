因为处于忙等待的线程仍然在持续使用 CPU，所以忙等待不是限制临界区访问的最理想方法，这里有两个更好的方法：**互斥量和信号量。互斥量是互斥锁的简称，它是一个特殊类型的变量，通过一些函数，互斥量可以用来限制每次只有一个线程能进入临界区。互斥量保证了一个线程独享临界区，其它线程在有线程已经进入该临界区的情况下，不能同时进入**

​	互斥量的数据类型为：`pthread_mutex_t`，在使用该类型的变量前，必须由系统对其进行初始化，初始化函数为：

```c++
int pthread_mutex_init(pthread_mutex_t* mutex_p, const pthread_mutexattr_t* attr_p);
```

我们一般不使用第二个参数，所以第二个参数一般为 NULL

使用完互斥量以后，它应该调用：

```c++
int pthread_mutex_destory(pthread_mutex_p* mutex_p);
```

来回收互斥量

要获得临界区的访问权，线程需调用：

```c++
int pthread_mutex_lock(pthread_mutex_p* mutex_p);
```

当线程退出临界区后，它应该调用：

```c++
int pthread_mutex_unlock(pthread_mutex_p* mutex_p);
```

调用lock会使线程等待，直到没有其它线程进入临界区，  调用unlock则通知系统该线程已经完成了临界区中代码的执行，互斥锁初始化后是开锁状态

通过声明一个全局的互斥量，可以在求全局和的程序中用互斥量代替忙等待。

第一个调用 pthread_mutex_lock 的线程会为临界区锁门，其它线程如果也想要进入到临界区，也需要先调用 pthread_mutex_lock，这些调用了该函数的线程都会阻塞并且等待，直到第一个线程离开临界区，只有第一个线程调用了 unlock 以后，系统才会从那些阻塞的线程中选取一个线程使其进入临界区

程序员通常会说，pthread_mutex_lock 函数返回的线程获得了互斥量或者拿到了锁，pthread_mutex_unlock 常称为释放一个锁或互斥量

```c++
pthread_mutex_lock(&mutex);
sum += temp;
pthread_mutex_unlock(&mutex);
```



注意在使用互斥量的程序中，多个线程进入临界区的顺序是随机的，线程顺序由系统负责分配

只要线程数目不大于核的数目，忙等待和互斥量两种方案的运行时间的串行版本和并行版本之比约等于线程数，但如果线程数目大于核的数目，那么采用互斥量程序的性能仍然维持不变，但忙等待的程序性能会下降，原因是：假设有2个核和5个线程，假设线程0在临界区，下一个应该到线程1，而另一个核当前是线程5，然后下一个调度的线程调度到了线程3，则两个线程会一直处于忙等待的情况，直到操作系统将它们其中一个线程挂起，并调度线程1，才能结束忙等待

