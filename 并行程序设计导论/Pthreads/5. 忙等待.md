当线程0要执行 x = x + y时，它需要确认线程1此时没有执行同样的语句，一旦线程0确认后，其需要通知线程1此时线程0在执行该语句，同时线程0执行完该语句后，也要告诉线程1已经执行完该语句

实现上述的操作的方法最简单的就是使用标志变量，设 flag = 0为标志变量，代码如下：

```c++
y = my_rank;
while (flag != my_rank);
x = x + y;
flag++;
```

因为 flag 的初值为0，所以编号不为0的线程会在 while 循环不断循环，知道条件为假，而且在线程0执行 flag++ 之前，线程1都无法进入临界区执行 x = x + y，当线程0执行完临界区的代码时，执行 flag++，从而使线程1进入临界区

while 循环语句就是忙等待的一个例子，在忙等待中线程不停地测试某个条件，直到某个条件满足



需要注意的是，忙等待这种方法有效的前提是代码严格按照我们书写的顺序执行，有些编译器优化会修改我们代码执行顺序，编译器无法知道程序是否是多线程的，所以它不知道变量 x 和 flag 的值会被其它线程修改，比如上面代码只被一个线程执行，那么忙等待的顺序就不重要了，则编译优化为了充分利用寄存器，会将某些语句的顺序交换：

```c++
y = my_rank;
x = x + y;
while (flag != my_rank);
flag++;
```

这段代码会使忙等待失效，为了防止这种情况，最简单的方法就是关闭编译优化选项



因此忙等待不是控制临界区最好的方法，当线程1进入临界区之前，只能一遍又一遍地执行循环，这样如果线程0由于操作系统的原因出现延迟，则线程1只会浪费CPU周期，这对性能有极大的影响，此外关闭编译器优化也会对性能有影响



在进行下面的讨论之前，我们还是再继续看看上面的代码，如果最后flag的值比所有线程编号大，那么所有线程都无法继续进入临界区，所以我们不能单纯地将flag++，当从线程t - 1离开时，我们应该令flag的值变为0，所以更新方式为：

```c++
flag = (flag + 1) % t;
```



所以代码更新为：

```c++
void* Thread_sum(void* rank) {
    long my_rank = (long)rank;
    double factor;
    long long i;
    long long a = n / t;
    long long first = a * rank;
    
    if (first % 2 == 0) {
        factor = 1.0;
    } else {
        factor = -1.0;
    }
    
    for (int i = first; i < (rank + 1) * a; i++, factor = -factor) {
        while (flag != my_rank);
        sum += factor / (2 * i + 1);
        flag = (flag + 1) % t;
    }
    
    return NULL;
}
```

上述程序开两个线程来计算时，结果是正确的，而当n为10的8次方时，串行求和比并行求和快。双核系统上允许需要19.5秒，而串行只需2.8秒，开销是来自启动线程和合并线程吗？我们可以让线程执行一个什么都不做的函数，发现开销只为0.3毫秒，说明原因不在于线程的开销

我们可以看到在线程0完成临界区运算并将flag + 1时，线程1必须等待，线程1进入临界区后，线程0也需要等待运算，显然是因为等待使得整体的运行时间加倍



忙等待不是保护临界区唯一的办法，因为临界区的代码一次只能由一个线程执行，所以无论如何限制访问临界区，都必须串行地执行其中的代码，如果可能的话，我们应该最小化执行临界区的次数，能够大幅度提高性能的一个方法是，给每个线程配置私有变量来存储各自的部分和，然后用for循环一次性将所有的部分和加在一起算出总和，用了下面的代码后，当n为10的8次方时，运算时间减为1.5秒：

```c++
void* Thread_sum(void* rank) {
    long my_rank = (long)rank;
    double factor, my_sum = 0.0;
    long long i;
    long long a = n / t;
    long long first = a * rank;
    
    if (first % 2 == 0) {
        factor = 1.0;
    } else {
        factor = -1.0;
    }
    
    for (int i = first; i < (rank + 1) * a; i++, factor = -factor) {
        my_sum += factor / (2 * i + 1);
    }
    
    while (flag != my_rank);
    sum += my_sum;
    flag = (flag + 1) % t;
    
    return NULL;
}
```

