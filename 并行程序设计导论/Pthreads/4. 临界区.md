在上面的矩阵向量乘法中，线程只读取除了 y 以外的所有变量，在主函数创建线程后，除了 y 以外，没有任何共享变量被改写，而且对于 y 的改写，每个线程各自改变属于自己运算的那一部分，那如果多个线程同时更新同一内存单元的数据会怎样？



我们以计算Π为例：

$\pi = (1-\frac{1}{3}+\frac{1}{5} - \frac{1}{7}+...+(-1)^n\frac{1}{2n + 1}+...)$

项数越多，对Π的估计越准确



该计算式子的串行代码是：

```c++
double factor = 1.0;
double sum = 0.0;
for (int i = 0; i < n; i++, factor = -factor) {
    sum += factor / (2 * i + 1);
}
pi = 4 * sum;
```



我们用并行化的方式计算，假设项数为 n，线程数为 t，且 t 能整除 n，令 q = n / t，则线程0计算0到 q - 1项，线程1计算 q 到 2q - 1项，以此类推，对于第一项，如果为奇数，则符号为负，若为偶数，则符号为正，代码：

```c++
void* Thread_sum(void* rank) {
    long my_rank = (long)rank;
    double factor;
    long long i;
    long long a = n / t;
    long long first = a * rank;
    
    if (first % 2 == 0) {
        factor = 1.0;
    } else {
        factor = -1.0;
    }
    
    for (int i = first; i < (rank + 1) * a; i++, factor = -factor) {
        sum += factor / (2 * i + 1);
    }
    
    return NULL;
}
```

如果用2个线程运行该程序，且 n 值相对较小的情况下，程序结果和串行结果差不多，当 n 值增大时，单线程的结果计算地越来越准确，而双线程计算的结果反而变糟糕，即当多个线程尝试更新同一个共享变量时，会出现问题



首先需要知道的是两个变量的相加要使用多条机器指令，比如将一条 c 语句将存储单元 y 的内容加到存储单元 x 中去：x = x + y

因为 x 和 y 中的值都存储在计算机的主存中，无法直接进行加法运算，因为 x 和 y 都存储在计算机的主存中，无法直接进行加法运算，需要先将它们从主存中加载到 CPU 的寄存器中，才能进行加法运算，当运算完成后，必须将结果再从寄存器重新存储到主存中

**那么假设原始 x = 0，在线程0取数计算，但还未将结果存入到 x 时，线程1也取了 x 进行计算，此时 x 的值仍为0，然后线程0将 x + 1，存回 x，x 的结果为 x + 1，而线程1的任务是将 x + 2，计算的结果存回 x，x 的结果变为 x + 2，覆盖了原来的结果，而程序的目的是将 x 加3，这样就出现了问题**



当多个线程都要访问共享变量和共享文件这样的共享资源时，如果至少其中一个访问是更新操作，那么这些访问就可能导致某种错误，我们称之为**竞争条件**。在这个例子中，为了使代码产生正确的结果，需要保证一旦某个线程开始执行 x = x + y，其它线程在它未完成前不能执行此操作，因此代码 x  = x + y 就是一个临界区。临界区就是一个更新共享资源的代码段，一次只允许一个线程执行该代码段